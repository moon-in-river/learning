Ts 的条件类型使用 extends 判断类型的包含关系，而不是全等。
Infer 关键字可以提取类型中的部分重新命名成新类型，后续使用。
分布式条件类型其实是把联合类型分别代入泛型参数中去做判断并推导结果。前提条件是泛型参数没有被包裹是裸露的。
拓展：交叉类型里存在短路效应，但 any ＆会始终返回 any｡

## 工具类型

分类：改复对象属性可选、必选、只读；改变类型结构，快速声明新类型、从已有类型改变结构声明新类型；

类型推导：基于用户输入、其于已定义的位置反向推导用户输入的类型。
如何比较函数类型？入参逆变，返回值协变。

## 类型编程

在项目中如何使用 ts，检查前后端数据交互。
递归修饰属性。
修饰已知的属性，比如标记某对象类型部分已知属性为可选。
Flatten 辅助工具类型，将交叉对象类型展开合并为单层对象。
根据预期的键值类型， 找出属性名。比如找出函数类型的属性名。注意，可选属性对条件判断有影响。
基于结构的互斥工具类型。2 个接口不能同时拥有 2 个属性，同时刻只能互斥拥有。Without､ XOR｡
模板字符串类型的目的是增强字符串字面量的灵活性。字符串类型是模板字符串类型的子类型。结合索引类型查询操作符 keyof 与模板字符串类型，从已知对象推导出字符字面量的联合类型。通过 as 语法与模板字符串类型重映射对象类型的键名。在模板字符串类型中使用 infer 提取插槽位置的量。

## 工程应用

### 指令行

使用类型指令行内注释，覆盖全局配置。//@ ts-开头。@ ts -ignore 忽略单行错误，@ts- check 可以查 js 文件。

### 类型声明

类型声明使用 declare,不能使用=初始化。可以写声明，也可以用 ts 文件生成.d.ts 文件，都是便其他地方或其他人使用类型信息。使用 declare module 补充模块明，或者补充非代码文件的类型声明导入的时候就不报错了。@ types/开头的包是 ts 官方维护，避免增大 npm 包体积。还可以用 declare namespace 声明。根据同一类型会被合并的特性，可以扩展第三方模块、内置模块的类型声明。
三斜杠指令的作用是引入文件所依赖的外部类型声明，有三种不同属性， path ､types､ lib 分别适用于指定路径的类型声明、@types 模块、ts 内置的类型声明。
命名空间可以在 ts､ d.ts 中使用，其目的是实现简单的模块化功能，命名空间可以被合并，也可以嵌套使用，内层的命名空间需要 export｡在启用 allow umd gobal access 配置时，使用 export as namespace react 可以导出到全局。
扩展：几十条 import 需要有组织放置，混乱的顺序后期维护天崩。Js 文件可以通过 jsdoc 获取类型提示，还可以使用 isdoc 提供的能力， 在@type 中使用 import 语句。
React 使用 ts 时应多关注事件类型、样式类型。
扩展：Parcel 是一个 bundler,零配置构建工具。
Ts 中独有的装饰器，实际上就是个函数，有 5 个应用场景， 类、方法、访问符、属性、参数。

#### isolated declarations

为啥官网又是 isolated modules?

babel 等转译器有限制，一次只能处理一个文档。不是基于整个文件系统的理解来进行转译。
ts(transpileModule api) 同样有这样的限制。导致一些运行时错误发生。例如：

- export 没有值的修饰符，单文件类型的转译器并不知道导出的是值还是类型
- 非模块文件不能用 namespace，除非 export {} 声明是一个模块
- 引用枚举常量的成员参与计算
> @2025/3/1 TODO: 没遇到过这些报错，如何复现看看？

设置 isolatedDeclarations 选项，可以解决这些问题。
